---
title:多重背包
data:2022-09-19 22:53:47
author:CHENSHONE
tags:[DP,背包]
categories:[算法]
---

# 多重背包

多重背包问题是完全背包的拓展版，题目如下：

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式

输出一个整数，表示最大价值。

数据范围

0<N,V≤100

0<$v_i,w_i,s_i$≤100

## 思路

跟完全背包不同的是，每个物品的数量是有限的。

f[i,j]表示从前i个物品中选，体积为j的选法的集合

属性为max

状态计算：

1.   第i个物品不选, f[i-1,j]
2.   第i个物品选k个 f[i-1,j-k*v] + k\*w

求max

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N], s[N];
int dp[N][N];

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i];

    for(int i = 1; i <= n; i++)
        for(int j = 0 ;j <= m; j++)
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]);
    cout << dp[n][m] << endl;
    return 0;
}

```

## 例题

### 多重背包（二进制优化）

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式

输出一个整数，表示最大价值。

数据范围

0<N≤1000

0<V≤2000

0<$v_i,w_i,s_i$≤2000

提示：

本题考查多重背包的二进制优化方法。

#### 思路

完全背包的优化思路
$f[i,j]=max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+s*w)$

$f[i,j-v]=max(       f[i-1,j-v], f[i-1,j-2v]+w,...,f[i-1,j-sv]+(s-1)*w,f[i-1,j-(s+1)*v]+s*w)$

这里f[i,j-v]多了一项，这样是求不出来f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw的max的

因此，换种思路把第i种物品共s个，打包一下
比如 有1023个，分别打包成1,2,4,8，……，512 共10组
那么，
1可以表示0~1，
1，2可以表示可以表示0~3，
1,2,4可以表示0~7
……
1,2,4,8，……，512可以表示0~1023
这样，就可以把s个第i中物品看成1个i号物品,2个i号物品,4个i号物品,8个号i物品，……，512个i号物品，共10个新的物品，每个新物品可以拿0次或1次，这样就可以枚举出s个i号物品所有方案，每号物品都这样处理，那么就可以转换成0-1背包问题

当然，上面的例子是2的整次幂-1的情况，如果是一个一般的数，比如200
那么可以分成 1,2,4,8,16,32,64,73
128是不能要的
1,2,4,8,16,32,64可以组合成0~127
加上73就可以组合成0~200

这就是背包问题的二进制优化

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

// 共n件物品，每件物品s个，采用下面的二进制优化，就把s个分成logs个新组（向上取整）
// 2000*log2000 ≈ 22000
const int N = 25000;

int n, m;
int v[N], w[N];
int f[N];

int main() {
    cin >> n >> m;

    int cnt = 0;  // 表示每个新物品的编号
	
    for(int i = 1; i <= n ; i++){
        int vv, ww ,s;
        cin > vv >> ww >> s;
        int k = 1;
        while(k <= s){
            cnt++;
            v[cnt] = k*vv;
            w[cnt] = k*ww;
            s -= k;
            k <<= 1;
        }
        if(s > 0){
            cnt++;
            v[cnt] = s*vv;
            w[cnt] = s*ww;
        }
    }
    
    for(int i = 1; i <= cnt; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    
    cout << f[m] << endl;
    return 0;
}

```

### 多重背包问题（单调队列优化）

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。

输出最大价值。

输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

输出格式

输出一个整数，表示最大价值。

数据范围

0<N≤1000

0<V≤20000

0<$v_i,w_i,s_i$≤20000

提示：

本题考查多重背包的单调队列优化方法。

输入样例

4 5

1 2 3

2 4 1

3 4 3

4 5 2

输出样例：

10
#### 思路

完全背包的优化思路
$f[i,j]=max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)$
$f[i,j-v]=max(f[i-1,j-v],f[i-1,j-2v]+w,...,f[i-1,j-sv]+(s-1)w,f[i-1,j-(s+1)v]+sw)$
这里f[i,j-v]多了一项，这样是求不出来f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw的max的
同样的 f[i,j-2v]也是"往后退一格"

可以看到f[i,j]是跟f[i-1,j],f[i-1,j-v],...,f[i-1,j-sv] 有关, 共s+1个
f[i,j-v]又跟f[i-1,j-v],f[i-1,j-2v],...,f[i-1,j-(s+1)v]有关, 共s+1个
也就是说每个f[i,j]都跟前面的s+1个f[i-1]有关
也就是说，每一个f[i,j]都是求s+1个f[i-1]的max
且j,j-v,j-2v,...这些数都有一个共同的特点，那就是模v的余数r相同
那么假设有这样一个数轴，数轴上的点记录了f[i-1]的值
r, r+v, r+2v,..., j-v, j
由上面分析可知，在这样一个数轴上取一个长度为s的滑动窗口，
例如窗口右端点在j，那么窗口内的max就是f[i,j]所需要的那个值
同理，右端点在j-v上，窗口内的max就是f[i,j-v]所需要的那个值
求一个滑动窗口内的max，可以使用单调队列来解决

又因为f[i,j]求max时，会跟着一个w的等差数列
所以，在单调队列中也要体现出这一点
所以，在一个元素进队列时，需要减去相应数量个w(先进队列的减得少，后进的减得多，这样就可以保证他们直接的相对大小了)
举个例子，
f[i,j]=max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2v]+2w,...,f[i-1,j-sv]+sw)
进入单调队列的是f[i-1,j],f[i-1,j-v],...,f[i-1,j-sv]
但是在单调队列中，需要考虑w带来的影响
因此在入队比较时，应该各自减去sw 这样就可以做到相对大小了

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 20010;

int n, m;
// g[N] 为f[N]的上一层状态，滚动数组
// q[N] 存的是g[]数组下标，也就是体积，单调队列，队头为max
int f[N], g[N], q[N];

int main() {
    cin >> n >> m;

    for (int i = 0; i < n; i++) {
        int v, w, s;
        cin >> v >> w >> s;
        // 保存上一层
        memcpy(g, f, sizeof f);
        // 枚举体积v的余数
        for (int j = 0; j < v; j++) {
            int hh = 0, tt = -1;
            for (int k = j; k <= m; k += v) {
                // 队头元素滑出窗口
                // k-s*v是当前求f[i,k]的滑动窗口的最左边的体积
                // 如果q[hh]比这个还小的话，就说明q[hh]不属于这个区间范围了
                if (hh <= tt && q[hh] < k - s * v) hh++;
                if (hh <= tt) f[k] = max(f[k], g[q[hh]] + (k - q[hh]) / v * w);
                // 这里是单调队列剔除元素
                // 因为分析时，f求max的时候各个元素会加上不同个数的w，也就偏移量
                // 那么在单调队列内，需要减去相应个数的偏移量
                while (hh <= tt &&
                       g[q[tt]] - (q[tt] - j) / v * w <= g[k] - (k - j) / v * w)
                    tt--;
                q[++tt] = k;
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

### 庆功会

为了庆贺班级在校运动会上取得全校第一名成绩，班主任决定开一场庆功会，为此拨款购买奖品搞劳运动员。

期望拨款金额能购买最大价值的奖品，可以补充他们的精力和体力。

输入格式

第一行二个数n,m,其中n代表希望购买的奖品的种数，m表示拨款金额。

接下来行，每行3个数，v、w、s,分别表示第i种奖品的价格、价值（价格与价值是不同的概念）和能购买的最

大数量（买0件到s件均可）。

输出格式

一行：一个数，表示此次购买能获得的最大的价值（注意！不是价格）。

数据范围

n≤500，m≤6000，

v≤100，w≤1000，s≤10

输入样例：

5 1000

80 20 4

40 50 9

30 50 7

40 30 6

20 20 1

输出样例：

1040

#### 思路

*本题复杂度大约为 n\*m\*s = 500\*6000\*10 = 3e7 不会超时，所以用最朴素的做法即可

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 6010;

int n, m;
int f[N];

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++){
        int v,w,s;
        scanf("%d%d%d", &v,&w,&s);
        for(int j = m; j >= 0; j--)
            for(int k = 0; k <= s && k*v <= j; k++)
                f[j] = max(f[j], f[j-k*v]+k*w);
    }
    cout << f[m] << endl;
    return 0;
}
```

