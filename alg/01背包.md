---
title:01背包
data:2022-09-08 23:41:13
author:CHENSHONE
tags:[DP,背包]
categories:[算法]
---

# 01背包

背包问题是动态规划(DP)的经典模型，01背包是背包模型中最简单的一种。

## 模型描述

有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。第 $i$ 件物品的体积是 $V_i$，价值是 $W_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

## 分析

首先，dp是一种用一个值（属性）代表一类状态（集合）的思想。

看本题，题目所求的是装完一些物品后，这些物品在总体积不超过背包容量的情况下，总价值要最大。这里显然就有两个维度的限制，一个是物品数量，一个是体积。体积很好理解，因为不能超过背包容量。其次，题目规定每件物品最多只能使用一次，也就是时候一件物品，要么不装进背包，要么只能装一个，所以物品数量也是个限制维度。

### 状态定义

我们可以这样考虑，设一个状态$f[i,j]$，这个状态表示的是在前$i$个物品中选，且总容量不超过$j$的所有选法的集合。这样一个集合中的所有不同方案，我们要求的是什么呢？是其总价值的最大值，所以这个状态的属性就是$max$。

### 状态转移

定义好了状态，接下来就要考虑状态之间应该如何转移。其实也就是上述的集合，应该怎样不重不漏划分成不同的子集。

可以这样考虑，$f[i,j]$按第$i$个物品选不选来划分，可以将$f[i,j]$这个集合划分成两个集合：

1.   不选第$i$个物品: 那就是等价于是$f[i-1,j]$；
2.   选择第$i$个物品: 如果要选择第$i$个物品的话，因为集合的属性的要找当前这一类方案中的价值总凉最大值，所以，就要在背包容量不超的前提下，加上第$i$个物品的价值要最大，也就是$f[i-1,j-v_i] + w_i$。

然后两种情况取一个max即可得到$f[i,j]$。

### 初始化

最后再考虑下初始化的问题，$f[i][j]$，当$i$是0的时候，无论$j$取多少，$f[i][j]$都是0。因为一件物品都不放，总价值必然是0。

## 模板题示例

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 $v_i$，价值是 $w_i$。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
数据范围
0<N,V≤1000
0<$v_i,w_i$≤1000

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int dp[N][N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    // dp[0][0~m] 表示前0个物品，所以都是0，全局变量初始化就是0
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            // 当前背包容量放得下第i件物品时
            if (j >= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);
        }
    }

    cout << dp[n][m] << endl;
    return 0;
}
```

## 优化

根据上面的代码可以看到，$dp[i][j]$只与$dp[i-1]$有关，因此可以删去一维，又因为$dp[i][j]$是依赖$dp[i-1][j]$及其前面的值的，所以，删去第一维之后，需要从后往前遍历。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int dp[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];

    // dp[0][0~m] 表示前0个物品，所以都是0，全局变量初始化就是0
    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= v[i]; j--) {
            // 如果从小到大遍历的话，dp[j - v[i]]其实是dp[i][j - v[i]]
            // 因为dp[j - v[i]]会比dp[j]先计算，也就是已经得到了
            // dp[i][j - v[i]],我们要的是dp[i - 1][j - v[i]]，所以这是不对的
            // 从大到小遍历的话，就可以保证 dp[j - v[i]]是dp[i-1][j - v[i]]
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }

    cout << dp[m] << endl;
    return 0;
}

```

## 例题

### 装箱问题

有一个箱子容量为V,同时有n个物品，每个物品有一个体积（正整数）。
要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。
输入格式
第一行是一个整数V,表示箱子容量。
第二行是一个整数n,表示物品数。
接下来n行，每行一个正整数（不超过10000），分别表示这n个物品的各自体积。
输出格式
一个整数，表示箱子剩余空间。
数据范围
0<V≤20000，
0<n≤30
输入样例：
24
6
8
3
12
7
9
7
输出样例：
0

>   将体积看成价值的话，就可以转化成一个01背包问题。剩余空间就小，就是总体积（价值）最大。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 20010;

int n,m;
int f[N];

int main(){
    cin >> m >> n;
    for(int i = 0; i < n;i++){
        int v;
        cin >> v;
        for(int j = m; j >= v; j--)
            f[j] = max(f[j],f[j-v] + v);
    }
    cout << m - f[m] << endl;
    return 0;
}
```

### 采药

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。

医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

输入格式

输入文件的第一行有两个整数T和M,用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。

接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

输出格式

输出文件包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

数据范围

1≤T≤1000

1<M≤100

输入样例：

70 3

71 100

69 1

1 2

输出样例：

3

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int n,m;
int f[N];

int main(){
    cin >> m >> n;
    for(int i = 1; i <= n; i++){
        int v, w;
        cin >> v >> w;
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j-v] + w);
    }
    cout << f[m] << endl;
    return 0;
}
```

### 数字组合

给定N个正整数$A_1,A_2,...,A_N$,从中选出若干个数，使它们的和为M,求有多少种选择方案。

输入格式

第一行包含两个整数N和M。

第二行包含N个整数，表示$A_1,A_2,...,A_N$。

输出格式

包含一个整数，表示M。

数据范围

1≤N≤100

1≤M≤10000

1≤$A_i$≤1000

输入样例：

4 4

1 1 2 2

输出样例：

3

>M看成背包容量
>
>每个数看成一个物品，数字大小看成体积
>
>目标：求出总体积恰好为M的方案数
>
>状态表示$f[i,j]$
>
>集合: 从前i个物品中选，体积恰好为j的方案的集合
>
>属性: count
>状态计算
>
>1. 第i个物品不选，$f[i-1,j]$
>2. 第i个物品选，$f[i-1,j - v_i]$
>    二者相加记为f[i,j]
>
>初始状态
>
>$f[0][0]$，一个物品不选，体积为0的方案有一种。
>
>$f[0][j]$，一个物品不选，体积不为0的方案有0种。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 10010;

int n,m;
int f[N];

int main(){
    cin >> n >> m;
    f[0] = 1;
    for(int i = 1; i <= n; i++){
        int v;
        cin >> v;
        for(int j = m; j >= v; j--)
            f[j] += f[j-v];
    }
    cout << f[m] << endl;
    return 0;
}
```

### 背包问题求具体方案

有N件物品和一个容量是V的背包。每件物品只能使用一次。第i件物品的体积是$v_i$,价值是$w_i$。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。

输出字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是1...N。

输入格式

第一行两个整数，N,V,用空格隔开，分别表示物品数量和背包容积。

接下来有N行，每行两个整数$v_i,w_i$,用空格隔开，分别表示第i件物品的体积和价值。

输出格式

输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。

物品编号范围是1...N。

数据范围

0<N,V≤1000

0<$v_i,w_i$≤1000

输入样例

4 5

1 2

2 4

3 4

4 6

输出样例：

1 4

>   求具体方案类似于最短路问题，其实就是根据当前状态反推出前一个状态$f[i,j]$ 是等于 $f[i-1,j]$还是$f[i-1,j-v_i] + w_i$
>
>   字典序最小输出
>   贪心
>   每个物品选择：
>   	1. 只能选      必选   f[i,j] = f[i-1,j-v] + w
>
>   2. 不能选      必不选 f[i,j] = f[i-1,j]
>   3. 可选可不选   必选   f[i-1,j] == f[i-1,j-v] + w
>        因为是从小到大求dp
>        因此这样的话，就可以保证方案的字典序最小
>
>   反推状态是从后往前
>
>   贪心字典序是从前往后
>
>   为了能够统一起来
>
>   循环状态的时候从后往前，这样反推状态的时候就是从前往后了

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    // 物品反着求状态
    for (int i = n; i >= 1; i--)
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i + 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
        }

    // f[1][m]是最大价值
    int j = m;
    // 因为前面状态的物品是反着求的，这里正着贪心即可
    for (int i = 1; i <= n; i++)
        // 选择当前物品
        if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i]) {
            cout << i << ' ';
            j -= v[i];
        }
    cout << endl;
    return 0;
}
```

### 潜水员（二维费用背包）

潜水员为了潜水要使用特殊的装备。
他有一个带2种气体的气缸：一个为氧气，一个为氨气。
让潜水员下潜的深度需要各种数量的氧和氨。
潜水员有一定数量的气缸。
每个气缸都有重量和气体容量。
潜水员为了完成他的工作需要特定数量的氧和氨。
他完成工作所需气缸的总重的最低限度的是多少？
例如：潜水员有5个气缸。每行三个数字为：氧，氨的（升）量和气缸的重量：
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
如果潜水员需要5升的氧和60升的氨则总重最小为249(1,2或者4,5号气缸)。
你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。
输入格式
第一行有2个整数m,n。它们表示氧，氨各自需要的量。
第二行为整数k表示气缸的个数。
此后的k行，每行包括$a_i, b_i, c_i$,3个整数。
这些各自是：第$i$个气缸里的氧和氨的容量及汽缸重量。
输出格式
仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。
数据范围
1≤m≤21，
1≤n≤79，
1≤k≤1000
1≤$a_i$≤21，
1≤$b_i$≤79,
1≤$c_i$≤800
输入样例：
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
输出样例
249

>   状态表示 $f[i,j,k]$
>   集合：所有只从前$i$个物品中选，且总体积至少为$j$，总重量至少为$k$的选法
>   属性：MIN
>   状态计算(集合划分)
>
>   1. 不包含第i个物品的选法: $f[i-1,j,k]$
>   2. 包含第i个物品的选法: $f[i-1,j-a[i],k-b[i]] + c[i]$
>
>   注意，初始化
>   $f[0,0,0] = 0$,
>   $f[0,j,k]$ 是不合法的，因此 $f[0,j,k] = INF (j,k \neq 0)$
>   这样的话，当其他状态从f[0,j,k] 转过来时候，就是不合法，不会被更新

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 25, M = 80;

int n,m;
int K;
int f[N][M];

int main() {
    cin >> n >> m >> K;
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;
    while (K--) {
        int v1, v2, w;
        cin >> v1 >> v2 >> w;
        for (int i = n; i >= 0; i--)
            for (int j = m; j >= 0; j--)
                // 当遇到INF时，不会被更新，比将不合法设为-1少一些判断代码
                // 当集合含义表示为至少时，i-v1，j-v2可以为负数，是合法的
                // 置为0即可，至少为负数与至少为0是一样的
                // 因为本题的所有v1,v2都是≥1的
                // 因此如果为负数就肯定表示一件物品也没选
                // 所以和0是等价的
                f[i][j] = min(f[i][j], f[max(0, i - v1)][max(0, j - v2)] + w);
    }
    cout << f[n][m] << endl;
    return 0;
}
```

### 宠物小精灵之收服

宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。
一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。
小智也想收服其中的一些小精灵。
然而，野生的小精灵并不那么容易被收服。
对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对
皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。
当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0
的野生小精灵也不会被小智收服。
当小智的精灵球用完时，狩猎也宣告结束。
我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。
如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选
择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。
小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘
受到的伤害越小（剩余体力越大），因为他们还要继续冒险。
现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服
过程中会对皮卡丘造成的伤害数目。
请问，小智该如何选择收服哪些小精灵以达到他的目标呢？
输入格式
输入数据的第一行包含三个整数：N,M,K,分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的
数量。
之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对
皮卡丘造成的伤害。
输出格式
输出为一行，包含两个整数：C,R,分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值
最多为R。
数据范围
0<N<1000
0<M<500,
0<K≤100
输入样例1：
10 100 5
7 10
2 40
2 50
1 20
4 20
输出样例1：
3 30
输入样例2：
10 100 5
8 110
12 10
20 10
5 200
1 110
输出样例2：
0 100

>   二维费用的背包问题
>   费用1：精灵球数量
>   费用2：皮卡丘体力
>   价值：小精灵数量
>   f[i,j,k] 表示只从前i个物品中选，且费用1不超过j，费用2不超过k的选法的最大价值
>   f[i,j,k] = max(f[i-1,j,k],f[i-1,j-v1[i],k-v2[i]] + 1)
>
>   收服最多的小精灵数量f[K,N,M]
>   最少耗费体力m f[K,N,m] == f[K,N,M]
>
>   题目要求皮卡丘的体力不能等于0
>   也就是费用2不能全部用光
>   也就是体力最少也得剩下1

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1010, M = 510;

int n, V1, V2;
int f[N][M];

int main() {
    cin >> V1 >> V2 >> n;
    for (int i = 0; i < n; i++) {
        int v1, v2;
        cin >> v1 >> v2;
        for (int j = V1; j >= v1; j--)
            for (int k = V2 - 1; k >= v2; k--)
                f[j][k] = max(f[j][k], f[j - v1][k - v2] + 1);
    }

    cout << f[V1][V2 - 1] << ' ';
    int k = V2 - 1;
    while (k > 0 && f[V1][k - 1] == f[V1][V2 - 1]) k--;
    cout << V2 - k << endl;
    return 0;
}
```

### 开心的金明

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。
更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，
你说了算，只要不超过$N$元钱就行。
今天一早，金明就开始做预算了，
金明想买的东西很多，肯定会超过妈妈限定的$N$元。
于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。
他还从因特网上查到了每件物品的价格（都是10元的整数倍）。
他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
设第j件物品的价格为$v[j]$,重要度为$w[j]$,共选中了$k$件物品，编号依次为$j_1,j_2,..,j_k$,则所求的总和为：
$v[j_1]*w[j_1]+v[j_2]*w[j_2]+...+v[j_k]*w[j_k]$(其中$*$为乘号)
请你帮助金明设计一个满足要求的购物单。
输入格式
输入文件的第1行，为两个正整数，用一个空格隔开：N m,
其中N表示总钱数，m为希望购买物品的个数。
从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数v p,其中v表示该物品的价格，p表示该物品的重要度(1~5)。
输出格式
输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值(<100,000,000)。
数据范围
1 ≤ N < 30000
1 ≤ m < 25
0 ≤ v ≤ 10000
1 ≤ p ≤ 5
输入样例：
1000 5
800 2
400 5
300 5
400 3
500 2
输出样例：
3900

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 30010;

int n, m;
int f[N];

int main(){
	scanf("%d%d", &m, &n);
    while(n--){
		int v, p;
        scanf("%d%d", &v,&p);
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j-v] + v*p);
    }
    printf("%d\n", f[m]);
    return 0;
}
```

### 能量石

岩石怪物杜达生活在魔法森林中，他在午餐时收集了N块能量石准备开吃。
由于他的嘴很小，所以一次只能吃一块能量石。
能量石很硬，吃完需要花不少时间。
吃完第$i$块能量石需要花费的时间为$S_i$秒。
杜达靠吃能量石来获取能量。
不同的能量石包含的能量可能不同。
此外，能量石会随着时间流逝逐渐失去能量。
第i块能量石最初包含$E_i$单位的能量，并且每秒将失去$L_i$单位的能量。
当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。
能量石中包含的能量最多降低至0。
请问杜达吃完所有石头可以获得的最大能量是多少？
输入格式
第一行包含整数T,表示共有T组测试数据。
每组数据第一行包含整数N,表示能量石的数量。
接下来N行，每行包含三个整数$S_i,E_i,L_i$。
输出格式
每组数据输出一个结果，每个结果占一行。
结果表示为“Case #x: y”,其中x是组别编号（从开始），y是可以获得的最大能量值。
数据范围
$1≤T≤100$
$1≤N≤100$
$1≤S_i≤100$
$1≤E_i≤10^5$
$0≤L_i≤10^5$
输入样例：
3
4
20 10 1
5 30 5
100 30 1
5 80 60
3
10 4 1000
10 3 1000
10 8 1000
2
12 300 50
5 200 0
输出样例：
Case #1: 105
Case #2: 8
Case #3: 500
样例解释
在样例#1中，有N=4个宝石。杜达可以选择的一个吃石头顺序是：
吃第四块石头。这需要5秒，并给他80单位的能量。
吃第二块石头。这需要5秒，并给他5单位的能量（第二块石头开始时具有30单位能量，5秒后失去了25单位的能量）。
吃第三块石头。这需要100秒，并给他20单位的能量（第三块石头开始时具有30单位能量，10秒后失去了10单位的能量）。
吃第一块石头。这需要20秒，并给他0单位的能量（第一块石头以10单位能量开始，110秒后已经失去了所有的能星）。
他一共获得了105单位的能量，这是能获得的最大值，所以答案是105。
在样本案例#2中，有N=3个宝石。
无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。
所以他应该吃第三块石头，给他提供8单位的能量。
在样本案例#3中，有N=2个宝石。杜达可以：
吃第一块石头。这需要12秒，并给他300单位的能量。
吃第二块石头。这需要5秒，并给他200单位的能量（第二块石头随着时间的推移不会失去任何能量！）。
所以答案是500。

>首先，能量为0的能量石吃了没有意义的，只会浪费时间，所以舍去
>将这个问题看成一个集合问题
>整个大的集合表示所有不同吃法的最优解
>这里的不同有两个维度
>
>1.   选择吃掉哪些能量石，能量变成0的能量石就不需要吃了
>2.   选择用什么样的顺序吃掉这些能量石
>
>两个维度的话 不要直接做
>先做一步贪心
>对于相邻的两颗能量石i和i+1
>先吃i再吃i+1，那么获得的能量就是 $E_i + E_{i+1} - S_i * L_{i+1}$
>先吃i+1再吃i，那么获得的能量就是$ E_{i+1} + E_i - S_{i+1} * L_i$
>如果说先吃i再吃i+1获得的能量多的话，就需要满足 $S_i * L_{i+1} < S_{i+1} * L_i$
>也就是 $\cfrac{S_i}{L_i} < \cfrac{S_{i+1}}{L_{i+1}}$
>
>这样，最优解的吃的顺序一定是按照$\cfrac{S_i}{L_i}$ 来升序排序的顺序
>
>经过上面的贪心，整个问题的范围就缩小到了排好序的一个序列中求最优解问题
>此时，只需要考虑哪些能量石吃不吃了
>这样就和01背包问题和类似了
>状态表示$f[i,j]$
>集合：只从前i个能量石中选，且总用时恰好为j的方案
>属性：MAX
>状态计算
>$f[i,j] = max(f[i-1,j], f[i-1, j - s] + e - (j - s) * L)$

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n, m;
struct Stone{
    int s, e, l;
    bool operator< (const Stone & S)const {
		return s*S.l < S.s*l;
    }
} stone[N];
int f[N];

int main(){
	int T;
    cin >> T;
    for(int C = 1; C <= T; C++){
        cin >> n;
        m = 0;
        for(int i = 0; i < n; i++){
            int s,e,l;
            cin >> s >> e >> l;
            stone[i] = {s,e,l};
            m += s;
        }
        sort(stone, stone+n);
        memset(f, -0x3f, sizeof f);
        f[0] = 0;
        for(int i = 0; i < n; i++){
            int s = stone[i].s, e = stone[i].e, l = stone[i].l;
			for(int j = m; j >= s; j--)
                f[j] = max(f[j], f[j - s] + e - (j - s) * l);
        }
        int res = 0;
        for(int i = 0; i <= m; i++) res = max(res, f[i]);
        printf("Case #%d: %d\n", C, res);
    }
    return 0;
}
```

