---
title:最长上升子序列模型
data:2022-10-12 22:56:45
author:CHENSHONE
tags:[DP,线性DP]
categories:[算法]
---

# 最长上升子序列（LIS）模型

## 问题描述
给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。
输入格式
第一行包含整数N。
第二行包含N个整数，表示完整序列。
输出格式
输出一个整数，表示最大长度。
数据范围
1≤N≤1000
$-10^9$≤ 数列中的数≤$10^9$

## 思路

$f[i]$，集合表示所有以i号字符结尾的所有上升子序列
属性表示子序列最长长度

状态计算（集合分类）
可以将集合分成$i-1$类
表示以$x$结尾的上升子序列集合
$f[i] = max(f[j]+1), j = 0,1,2,……,i-1$

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int n;
int w[N];
int f[N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];
    
    for(int i = 1; i <= n; i++){
        f[i] = 1;
        for(int j = 1; j < i; j++)
            if(w[j] < w[i]) f[i] = max(f[i], f[j] + 1);
    }
    int res = 0; 
    for(int i = 1; i <= n; i++) res = max(res, f[i]);
	cout << res << endl;
    return 0;
}
```

## 题目

### 最长上升子序列2

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。
输入格式
第一行包含整数N。
第二行包含N个整数，表示完整序列。
输出格式
输出一个整数，表示最大长度。
数据范围
1≤N≤100000，
$-10^9$≤数列中的数≤$10^9$

#### 思路
本题数据比例题要大的多

$f[i]$，集合表示所有以$i$号结尾的所有上升子序列
属性表示子序列最长长度

状态计算（集合分类）
可以将集合分成$i-1$类
表示以$x$结尾的上升子序列集合
$f[i] = max(f[j]+1), j = 0,1,2,……,i-1$

对于最长上升子序列长度相同的子集，我们只需要保留结尾最小的就可以了
因为结尾最小，它的包容性最好
比如，长度为2的上升子序列中，有两个，一个结尾是3，一个结尾是1
那么，结尾是3的能用的话，结尾是1的同样也能用

用一个数组存储当前不同长度的最长上升子序列的结尾的最小值

当前不同长度的最长上升子序列的结尾的最小值一定是一个单调递增的
因为，假设长度为5的上升序列的结尾的最小值比长度为4的小的话
长度为5的倒数第二个结尾的数是一定比结尾的那个数要小的
根据定义
也就是长度为4的结尾的最小值比长度为5的结尾最小值小
这与假设矛盾

设当前位置是$a[i]$，找当前不同长度的最长上升子序列的结尾的最小值中的小于$a[i]$最大值（二分）
与其连起来成为一个新的上升子序列
假设当前找到的最长上升子序列的长度为4
那么加上$a[i]$就是长度为5，且当前长度为5的最长上升子序列的结尾的最小值一定 ≥ $a[i]$
所以更新一下当前长度为5的最长上升子序列的结尾的最小值为$a[i]$

综上，遍历每个位置是O(n)，对于每个位置，用二分查找当前上升子序列的结尾最小值中的小于$a[i]$的最大值，复杂度为O(logn)，所以总的时间复杂度为 O(nlogn)

#### 代码

```cpp
#include<bist/stdc++.h>

using namespace std;

const int N = 100010;

int n;
int w[N];
int q[N];

int main(){
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &w[i]);
    
    int len = 0; // 当前已经找到的最长上升子序列长度
    q[0] = -2e9;
    
    for(int i = 0; i < n; i++){
        int l = 0; r = len;
        while(l < r){
            int mid = (l + r + 1) >> 1;
            if(q[mid] < w[i])
                l = mid;
            else
                r = mid - 1;
        }
        len = max(len, r + 1);
        q[r+1] = w[i]; // 更新下长度为r+1的最小值
    }
    return 0;
}
```

### 怪盗基德的滑翔翼

怪盗基德是一个充满传奇色彩的怪盗，专门以珠宝为目标的超级盗窃犯。
而他最为突出的地方，就是他每次都能逃脱中村警部的重重围堵，而这也很大程度上是多亏了他随身携带的便于
操作的滑翔翼。
有一天，怪盗基德像往常一样偷走了一颗珍贵的钻石，不料却被柯南小朋友识破了伪装，而他的滑翔翼的动力装
置也被柯南踢出的足球破坏了。
不得已，怪盗基德只能操作受损的滑翔翼逃脱。
假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。
初始时，怪盗基德可以在任何一幢建筑的顶端。
他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。
因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。
他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。
请问，他最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）？
输入格式
输入数据第一行是一个整数K,代表有K组测试数据。
每组测试数据包含两行：第一行是一个整数N,代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建
筑的高度h,按照建筑的排列顺序给出。
输出格式
对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。
数据范围
1≤K≤100
1≤N≤100
0<h<10000
输入样例：
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
输出样例：
6
6
9

#### 思路

往左走

从左往右看，以某一个点为结尾的最长上升子序列长度为多少

往右走

从右往左看，以某一个点为结尾的最长上升子序列长度为多少

#### 代码

```cpp
#include<bist/stdc++.h>

using namespace std;

const int N = 110;

int T, n;
int w[N];
int f[N];

int main(){
	cin >> T;
    while(T--){
		cin >> n;
        for(int i = 1; i <= n; i++) cin >> w[i];
        
        int res = 0;
        // 正向求解LIS
        for(int i = 1; i <= n; i++){
            f[i] = 1;
            for(int j = 1; j < i; j++)
                if(w[j] < w[i])
                    f[i] = max(f[i], f[j] + 1);
            res = max(res, f[i]);
        }
        // 反向求解LIS
        for(int i = n; i > 0; i--){
			f[i] = 1;
            for(int j = n; j > i; j--)
                if(w[j] < w[i])
                    f[i] = max(f[i], f[j] + 1);
            res = max(res, f[i]);
        }
        cout << res << endl;
    }
    return 0;
}
```

### 登山

五一到了，ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点
即每次所浏览景点的编号都要大于前一个浏览景点的编号。
同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。
队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？
输入格式
第一行包含整数N,表示景点数量。
第二行包含N个整数，表示每个景点的海拔。
输出格式
输出一个整数，表示最多能浏览的景点数。
数据范围
2≤N≤1000
输入样例：
8
186 186 150 200 160 130 197 220
输出样例：
4

#### 思路

条件1：
按照编号递增的顺序来浏览 -> 子序列
条件2：
相邻两个景点不能相同
条件3：
一旦开始下降，就不能上升了 -> 景点海拔只能先递增后递减
目标：
求最多能浏览多少景点

求以每个点为顶点的值取max即可
以求a[k]为顶点为例
求出从左往右，以a[k]为结尾的LIS
再求出从右往左，以a[k]为结尾的LIS
相加再减1即可(a[k]仅保留一次)

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int n;
int w[N];
int f[N], g[N]; // f[] 从左往右上升子序列，g[]从右往左上升子序列

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];
    
    // 从左往右
    for(int i = 1; i <= n; i++){
		f[i] = 1;
        for(int j = 1; j < i; j++)
            if(w[j] < w[i]) f[i] = max(f[i], f[j] + 1);
    }
    
    // 从右往左
    for(int i = n; i > 0; i--){
		g[i] = 1;
        for(int j = n; j > i; j--)
            if(w[j] < w[i]) g[i] = max(g[i], g[j] + 1);
    }
    
    int res = 0;
    for(int i = 1; i <= n; i++)
        res = max(res, f[i] + g[i] - 1);
    
    cout << res << endl;
    return 0;
}
```

### 合唱队形

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1,2.，K,他们的身高分别为
$T_1,T_2,……,T_K$,则他们的身高满足$T_1 <……< T_i > T_{i+1} > ... > T_K(1≤i≤K)$。
你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。
输入格式
输入的第一行是一个整数N,表示同学的总数。
第二行有个整数，用空格分隔，第i个整数T是第i位同学的身高（厘米）。
输出格式
输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
数据范围
2≤N≤100，
130≤Ti≤230
输入样例：
8
186 186 150 200 160 130 197 220
输出样例
4

#### 思路

去掉的同学最少，也就是先递增后递减的这个序列最长

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 110;

int n;
int a[N];
int f[N], g[N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    for(int i = 1; i <= n; i++){
        f[i] = 1;
        for(int j = 1; j < i; j++)
            if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
    }
    for(int i = n; i; i--){
		g[i] = 1;
        for(int j = n; j > i; j--)
            if(a[j] < a[i]) g[i] = max(g[i], g[j] + 1);
    }
    
    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res, f[i] + g[i] - 1);
    cout << n - res << endl;
    return 0;
}
```

### 友好城市

Palmia国有一条横贯东西的大河，河有笔直的南北两岸，岸上各有位置各不相同的N个城市。
北岸的每个城市有且仅有一个友好城市在南岸，而且不同城市的友好城市不相同。
每对友好城市都向政府申请在河上开辟一条直线航道连接两个城市，但是由于河上雾太大，政府决定避免任意两
条航道交叉，以避免事故。
编程帮助政府做出一些批准和拒绝申请的决定，使得在保证任意两条航线不相交的情况下，被批准的申请尽量
多。
输入格式
第1行，一个整数N,表示城市数。
第2行到第N+1行，每行两个整数，中间用1个空格隔开，分别表示南岸和北岸的一对友好城市的坐标。
输出格式
仅一行，输出一个整数，表示政府所能批准的最多申请数。
数据范围
1≤N≤5000，
0≤$x_i$≤10000
输入样例：
7
22 4
2 6
10 3
15 12
9 8
17 17
4 2
输出样例：
4

#### 思路

因为友好城市两两对应且唯一
因此二者之间可以视为存在某种映射关系
南岸所选中的要建航线的城市，从左往右，编号递增的情况下，对应到北岸，北岸的城市必然也需要是一个上升序列(从左往右的位置)



#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef pair<int,int> pii;

const int N = 5010;

int n;
pii q[N];
int f[N];

int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) scanf("%d%d", &q[i].first, &q[i].second);
    sort(q, q + n);
    
    int res = 0;
    for(int i = 1; i <= n; i++) {
        f[i] = 1;
        for(int j = 1; j < i; j++)
            if(q[j].second < q[i].second) f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
    }
    printf("%d\n", res);
    
    return 0;
}
```

### 最长上升子序列和

一个数的序列$b_i$,当$b_1<b_2<……<b_s$的时候，我们称这个序列是上升的。
对于给定的一个序列$(a_1,a_2,...,a_w)$,我们可以得到一些上升的子序列$(a_{i_1},a_{i_2},...,a_{i_k})$,这里$1≤i_1<i_2<...<i_k≤N$。
比如，对于序列(1,7,3,5,9,4,8)，有它的一些上升子序列，如(1,7), (3,4,8)等等。
这些子序列中和最大为18，为子序列(1,3,5,9)的和。
你的任务，就是对于给定的序列，求出最大上升子序列和。
注意，最长的上升子序列的和不一定是最大的，比如序列(100,1,2,3)的最大上升子序列和为100，而最长上升子序
列为(1,2,3)
输入格式
输入的第一行是序列的长度N。
第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。
输出格式
输出一个整数，表示最大上升子序列和。
数据范围
1≤N≤1000
输入样例：
7
1 7 3 5 9 4 8
输出样例：
18

#### 思路

只是集合所表示的属性从长度的max变成了和的max

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int n;
int w[N];
int f[N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];
    
    int res = 0;
    for(int i = 1; i <= n; i++){
        f[i] = w[i];
        for(int j = 1; j < i; j++)
            if(w[j] < w[i]) f[i] = max(f[i], f[j] + w[i]);
        res = max(res, f[i]);
    }
    
    cout << res << endl;
    
    return 0;
}
```



### 最长公共子序列(LCS)

给定两个长度分别为N和M的字符串A和B,求既是A的子序列又是B的子序列的字符串长度最长是多少。
输入格式
第一行包含两个整数N和M。
第二行包含一个长度为N的字符串，表示字符串A。
第三行包含一个长度为M的字符串，表示字符串B。
字符串均由小写字母构成。
输出格式
输出一个整数，表示最大长度。
数据范围
1≤N,M≤1000

#### 思路
f[i,j]
集合表示A前i个和B前j个的公共子序列
属性表示MAX

状态计算（集合分类）
可以将集合分成四类

|   情况   |  10  |  11  |  00  |  01  |
| :------: | :--: | :--: | :--: | :--: |
| A中第i个 |  √   |  √   |  x   |  x   |
| B中第i个 |  x   |  √   |  x   |  √   |

情况00：f[i-1,j-1]
情况11：f[i-1,j-1] + 1
情况01：不等价于f[i-1,j],但是f[i-1,j]包含01这种情况，因为是求MAX，所以可以用f[i-1,j]来表示
情况10：不等价于f[i,j-1],但是f[i,j-1]包含10这种情况，因为是求MAX，所以可以用f[i,j-1]来表示

可以看到这四种情况其实是有重合的，但本题要求MAX，因此重合是没有关系的
另外，00的情况被包含在01和10中，因此实际操作时可以省略

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int n, m;
char a[N], b[N];
int f[N][N];

int main() {
    cin >> n >> m;
    scanf("%s%s", a+1, b+1);
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m ;j++) {
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        }

    cout << f[n][m] << endl;
    return 0;
}
```

### 最长公共上升子序列

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。
小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序
列了。
小沐沐说，对于两个数列A和B,如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段
数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。
奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。
不过，只要告诉奶牛它的长度就可以了。
数列A和B的长度均不超过3000。
输入格式
第一行包含一个整数N,表示数列A,B的长度。
第二行包含N个整数，表示数列A。
第三行包含N个整数，表示数列B。
输出格式
输出一个整数，表示最长公共子序列的长度。
数据范围
1≤N≤3000，序列中的数字均不超过$2^{31}-1$
输入样例：
4
2 2 1 3
2 1 2 3
输出样例：
2

#### 思路
状态表示 f[i,j]
集合：所有由第一个序列的前i个数，第二个序列的前j个数，且以b[j]结尾的公共上升子序列
属性：MAX

状态计算
f[i,j]分成两部分
1. 所有包含a[i]的公共上升子序列 (也就是以a[i]结尾，按照状态表示 a[i] == b[j])，将该部分继续划分(按照LIS的方式，按序列倒数第二个数是哪个)成a[1]~a[i - 1]和b的前0个，前1个，……，前j-1个数(且以b[k]为结尾)的公共上升子序列，那么该部分就是f[i - 1,k] + 1
2. 所有不包含a[i]的公共上升子序列，也就是f[i-1,j]

整体大集合是按照LCS问题分的
第一个子集再按照LIS来分

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main() {
	cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) cin >> b[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++) {
            f[i][j] = f[i-1][j];
            if(a[i] == b[j]){
                int maxv = 1;
                for(int k = 1; k < j; k++)
                    if(b[k] < a[i]) maxv = max(maxv, f[i-1][k] + 1);
                f[i][j] = max(f[i][j], maxv);
            }
        }
    
    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    
    cout << res << endl;
    
    return 0;
}
```

#### 优化

我们发现每次循环求得的maxv是满足$a[i] > b[k]$的$f[i - 1][k] + 1$的前缀最大值。
因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。

##### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 3010;

int n;
int a[N], b[N];
int f[N][N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int j = 1; j <= n; j++) cin >> b[i];
    
    for(int i = 1; i <= n; i++) {
        int maxv = 1;
        for(int j = 1; j <= n; j++) {
            f[i][j] = f[i-1][j];
            if(a[i] == b[j])
                f[i][j] = max(f[i][j], maxv);
            if(b[j] < a[i])
                maxv = max(maxv, f[i - 1][j] + 1);
        }
    }
    
    int res = 0;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    
    cout << res << endl;
    
    return 0;
}
```

