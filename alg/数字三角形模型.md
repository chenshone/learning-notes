---
title:数字三角形模型
data:2022-10-12 00:33:37
author:CHENSHONE
tags:[DP,线性DP]
categories:[算法]
---

# 数字三角形

## 题意

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。



​        7

​      3   8

​    8   1   0

  2   7   4   4

4   5   2   6   5

输入格式

第一行包含整数 n，表示数字三角形的层数。



接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。



输出格式

输出一个整数，表示最大的路径数字和。



数据范围

1≤n≤500,

−10000≤三角形中的整数≤10000

## 思路

将这个三角变成右下三角，这样就可以给每个数标号

f[i,j]，集合表示所有从起点走到(i,j)的路径
属性表示MAX

状态计算（集合分类）
可以将集合分成两类
来自左上: f[i-1,j-1] + a[i,j]
来自右上: f[i-1,j] + a[i,j]

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n;
int a[N][N];
int f[N][N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            cin >> a[i][j];
    
    for(int i = 1; i <= n; i++)
        // 算每行最右侧的dp值时，会要dp[i-1][j] 所以要多初始化一个
        for(int j = 1; j <= i + 1; j++)
            f[i][j] = -INF;
    f[1][1] = a[1][1];
    
    for(int i = 2; i <= n; i++)
        for(int j = 1; j <= i; j++)
            f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j];
    
   	int res = -INF;
    for(int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res << endl;
    return 0;
}
```

## 例题

### 摘花生

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地（如下图），从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花

生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

<img src="https://cdn.jsdelivr.net/gh/chenshone/myPictureHost@main/learning-notes/20221012004824.png" alt="摘花生" style="zoom: 50%;" />

输入格式

第一行是一个整数T,代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述

了该行每株花生苗上的花生数目M。

输出格式

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

数据范围

1≤T≤100

1≤R,C≤100

0≤M≤1000

输入样例：
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5

输出样例：
8
16

#### 思路

状态表示 f[i,j]
集合: 所有从(1,1) 走到 (i,j)的路线
属性: MAX
状态计算——集合划分
集合划分最关键的一步: “最后”，也就是往往考虑根据走到该状态的最后一步进行划分

1. 最后一步是从上面走下来 f[i-1,j] + w[i,j]
2. 最后一步是从左边走过来 f[i,j-1] + w[i,j]

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 110;

int T, n, m;
int w[N][N];
int f[N][N];

int main(){
    cin >> T;
    while(T--){
        cin >> n >> m;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
                cin >> w[i][j];
        
        for(int i = 1; i <= n; i++)
			for(int j = 1; j <= m; j++)
                f[i][j] = max(f[i-1][j], f[i][j-1]) + w[i][j];

       	cout << f[n][m] << endl;
    }
    return 0;
}
```

### 最低通行费

一个商人穿过一个N×N的正方形的网格，去参加一个非常重要的商务活动。
他要从网格的左上角进，右下角出。
每穿越中间1个小方格，都要花费1个单位时间。
商人必须在(2N-1)个单位时间穿越出去。
而在经过中间的每个小方格时，都需要缴纳一定的费用。
这个商人期望在规定时间内用最少费用穿越出去。
请问至少需要多少费用？
注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。
输入格式
第一行是一个整数，表示正方形的宽度N。
后面N行，每行N个不大于100的整数，为网格上每个小方格的费用。
输出格式
输出一个整数，表示至少需要的费用。
数据范围
1≤N≤100
输入样例：
5
1  4  6  8  10
2  5  7  15 17
6  8  9  18 20
10 11 12 19 21
20 23 25 29 33
输出样例：
109
样例解释
样例中，最小值为109=1+2+5+7+9+12+19+21+33。

#### 思路

在(2N-1)个单位时间穿越出去，表示不能走回头路，与摘花生类似

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 110, INF = 0x3f3f3f3f;

int n;
int w[N][N];
int f[N][N];

int main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            cin >> w[i][j];
    
    for(int i = 0; i <= n; i++) f[0][i] = f[i][0] = INF;
    f[1][1] = w[1][1];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++){
         	if(i == 1 && j == 1) continue;
            f[i][j] = min(f[i-1][j], f[i][j-1]) + w[i][j];
        }
    cout << f[n][n] << endl;
    return 0;
}
```

### 方格取数

设有N×N的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：
<img src="https://cdn.jsdelivr.net/gh/chenshone/myPictureHost@main/learning-notes/image-20221012011100103.png" alt="image-20221012011100103" style="zoom:50%;" />
某人从图中的左上角A出发，可以向下行走，也可以向右行走，直到到达右下角的B点。
在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0)。
此人从A点到B点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。
输入格式
第一行为一个整数N,表示NxN的方格图。
接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数：
一行“0 0 0”表示结束。
输出格式
输出一个整数，表示两条路径上取得的最大的和。
数据范围
N<10

#### 思路

只走一次：
$f[i,j]$表示所有从(1,1)走到($i,j$)的路径的最大值
$f[i,j]=max(f[i-1,j]+w[i,j],f[i,j-1]+w[i,j])$
走两次：
$f[i_1,j_1,i_2,j_2]$表示所有从(1,1)，(1,1)分别走到($i_1,j_1$),($i_2,j_2$)的路径的最大值
如何处理“同一个格子不能被重复选择”
只有在$i_1+j_1=i_2+j_2$时，两条路径的格子才可能重合，也就是走相同步数才可能重合
$f[k,i_1,i_2]$表示所有从(1,1)，(1,1)分别走到($i_1,k-i_1$),($i_2,k-i_2$)的路径的最大值
k表示两条路线当前走到的格子的横纵坐标之和
$k=i_1+j_1=i_2+j_2$

状态计算
1. 第一条路线向下走、第二条路线向下走
     1. $i_1,j_1$和$i_2,j_2$重合, 只走一次，$f[k,i_1,i_2] = f[k-1,i_1-1,i_2-1] + w[i_1,j_1]$
     2. 不重合, $f[k,i_1,i_2] = f[k-1,i_1-1,i_2-1] + w[i_1,j_1] + w[i_2,j_2]$
2. 第一条路线向下走、第二条路线向右走
3. 第一条路线向右走、第二条路线向下走
4. 第一条路线向右走、第二条路线向右走

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 15;

int n;
int w[N][N];
int f[2*N][N][N];

int main(){
    cin >> n;
    int a,b,c;
    while(cin >> a >> b >> c, a || b || c) w[a][b] = c;
    
    for(int k = 2; k <= n+n; k++)
        for(int i1 = 1; i1 <= n; i1++)
            for(int i2 = 1; i2 <= n; i2++){
				int j1 = k - i1, j2 = k - i2;
                if(j1 >= 1 && j1 <= n && j2 >= 1 && j2 <= n){
                    int t = w[i1][j1];
                    if(i1 != i2) t += w[i2][j2]; // 不重合的话
                    int &x = f[k][i1][i2];
                    x = max(x, f[k-1][i1-1][i2-1] + t); // 1、2均往下走
                    x = max(x, f[k-1][i1][i2-1] + t); // 1往右，2往下
                    x = max(x, f[k-1][i1-1][i2] + t); // 1往下，2往右
                    x = max(x, f[k-1][i1][i2] + t); // 1、2均往右
                }
            }
    cout << f[n+n][n][n] << endl;
    return 0;
}
```

