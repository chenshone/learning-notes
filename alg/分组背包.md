---
title:分组背包
data:2022-09-29 22:39:01
author:CHENSHONE
tags:[DP,背包]
categories:[算法]
---

## 题意

有 N 组物品和一个容量是 V 的背包。

每组物品有若干个，同一组内的物品最多只能选一个。

每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

输入格式

第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。

接下来有 N 组数据：

每组数据第一行有一个整数 $S_i$，表示第 $i$ 个物品组的物品数量；

每组数据接下来有 $S_i$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值； 

输出格式 

输出一个整数，表示最大价值。

数据范围

0<N,V≤100

0<$S_i$≤100

0<$v_{ij},w_{ij}$≤100

## 思路

完全背包问题是枚举第$i$种物品选几个

分组背包问题是枚举第$i$组物品选哪个

所以$f[i,j] = max(f[i-1,j],f[i-1,j-v[i,k]]+w[i,k])$

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 110;

int n,m;
int v[N][N], w[n][N], s[N];
int f[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        for(int j = 1; j <= s[i]; j++)
            cin >> v[i][j] >> w[i][j];
    }
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 0; j--)
            for(int k = 0; k < s[i]; k++)
                if(j >= v[i][k]) f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);
    cout << f[m] << endl;
    
    return 0;
}
```

## 例题

### 机器分配

总公司拥有M台相同的高效设备，准备分给下属的N个分公司。

各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。

问：如何分配这M台设备才能使国家得到的盈利最大？

求出最大盈利值。

分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数M。

输入格式

第一行有两个数，第一个数是分公司数N,第二个数是设备台数M;

接下来是一个N*M的矩阵，矩阵中的第i行第j列的整数表示第i个公司分配j台机器时的盈利

输出格式

第一行输出最大盈利值；

接下N行，每行有2个数，即分公司编号和该分公司获得设备台数。

答案不唯一，输入任意合法方案即呵。

数据范围

1≤N≤10

1≤M≤15

输入样例：

3 3
30 40 50
20 30 50
20 25 30
输出样例：

70
1 1
2 1
3 1

#### 思路

可以看成分组背包问题，每个公司看成一个物品组，每个物品组中的物品则是分配不同设备台数，每个物品的体积是设备数量，每个物品的价值是其产生的效益

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 15, M = 20;

int n, m;
int w[N][M];
int f[N][M];
int way[N];

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> w[i][j];
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j--)
            for(int k = 0; k <= j; k++)
                f[i][j] = max(f[i][j], f[i-1][j-k] + w[i][k]);
    cout << f[n][m] << endl;
    
    int j = m;
    for(int i = n; i; i--)
        for(int k = 0; k <= j; k++)
            if(f[i][j] == f[i-1][j-k] + w[i][k]){
                way[i] = k;
                j -= k;
                break;
            }
	for(int i = 1; i <= n; i++)
        printf("%d %d", i, way[i]);
    
    return 0;
}
```

### 金明的预算方案

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。

更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行。”

今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，

下表就是一些主件与附件的例子：

主件      附件

电脑      打印机，扫描仪

书柜      图书

书桌      台灯，文具

工作椅   无

如果要买归类为附件的物品，必须先买该附件所属的主件。

每个主件可以有0个、1个或2个附件。

附件不再有从属于自己的附件。

金明想买的东西很多，肯定会超过妈妈限定的N元。

于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。

他还从因特网上查到了每件物品的价格（都是10元的整数倍）。

他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为$v[j]$,重要度为$w[j]$,共选中了$k$件物品，编号依次为$j_1,j_2,..,j_k$,则所求的总和为：

$v[j_1]*w[j_1]+v[j_2]*w[j_2]+...+v[j_k]*w[j_k]$(其中$*$为乘号)

请你帮助金明设计一个满足要求的购物单。

输入格式

输入文件的第1行，为两个正整数，用一个空格隔开：N m, 其中N表示总钱数，m为希望购买物品的个数。

从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，

每行有3个非负整数v p q, 其中v表示该物品的价格，p表示该物品的重要度(1~5)，q表示该物品是主件还是附件。

如果q=0,表示该物品为主件，如果q > 0,表示该物品为附件，q是所属主件的编号。

输出格式

输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值(<200000)。

数据范围

N < 32000, m < 60, v < 10000

输入样例：

1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0

输出样例：

2200

#### 思路

本质上是一个分组背包问题，将一组主件和附件看成一组。每一组中的选择包括：买主件+(附件的组合)

#### 代码

```cpp
#include <bits.stdc++.h>

#define v first
#define w second

using namespace std;

typedef pair<int, int> PII;

const int N = 65, M = 32010;

int n, m;
PII master[N]; // 主件
vector<PII> servent[N]; // 附件
int f[M];

int main(){
    cin >> m >> n;
    for(int i = 1; i <= m; i++) {
        int v, p, q;
        cin >> v >> p >> q;
        if(!q) master[i] = {v, v*p};
        else servent[i].push_back({v, v*p});
    }
    
    for(int i = 1; i <= n ; i++)
        if(master[i].v) { // 因为选附件必选主件，所以只需要计算主件存在的情况
            for(int j = m ;j >= 0; j--) {
                auto &sv = servent[i];
                // 每个附件选或不选都有两种选择，共2^servent[i].size()种情况
                for(int k = 0; k < 1 << sv.size(); k++) {
                    int v = master[i].v, w = master[i].w;
                    for(int u = 0; u < sv.size(); u++)
                        // k看成二进制，1表示选，0表示不选
                        if(k >> u & 1){
                            v += sv[u].v;
                            w += sv[u].w;
                        }
                    if(j >= v) f[j] = max(f[j], f[j - v] + w);
                }
            }
        }
    cout << f[m] << endl;
    
    return 0;
}
```

### 有依赖背包

有N个物品和一个容量是V的背包。

物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。

如下图所示：

<img src="https://cdn.jsdelivr.net/gh/chenshone/myPictureHost@main/learning-notes/image-20220930022902456.png" alt="image-20220930022902456" style="zoom: 25%;" />

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。

每件物品的编号是$i$,体积是$v_i$,价值是$w_i$,依赖的父节点编号是$p_i$。物品的下标范围是1...N。

求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。

输出最大价值。

输入格式

第一行有两个整数N,V,用空格隔开，分别表示物品个数和背包容量。

接下来有N行数据，每行数据表示一个物品。

第 $i$ 行有三个整数$v_i,w_i,p_i$,用空格隔开，分别表示物品的体积、价值和依赖的物品编号。

如果 $p_i=-1$，表示根节点。数据保证所有物品构成一棵树。

输出格式

输出一个整数，表示最大价值。

数据范围

1≤N,V≤100

1≤$v_i,w_i$≤100

父节点编号范围：

内部结点：$1≤p_i≤N$;

根节点 $p_i=-1$：

输入样例

5 7
2 3 -1
2 2 1
3 5 1
4 7 2
3 6 2

输出样例：

11

#### 思路

首先，这个一个树形DP问题。

$f[u,j]$表示所有从以u为根节点的子树中选，且总体积不超过j的方案
属性 max

状态计算
以u为根的树有多个子树
在每个子树中，按选中物品的总体积再划分
比如说，体积0~m，共m+1种选法，对于每种体积的选法求价值max，m+1种选法只能选择其中一个
这样，就可以将每个子树中不同体积的选法看成一组物品，多个子树就是多个物品组
这样，在考虑每个节点做根节点的时候，这个问题就变成了一个树形DP + 分组背包问题

当然 根据题意，如果一棵树中的某个点选择了，那么u这个根节点(物品)，是必选的

#### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 110;

int n, m;
int v[N], w[N];
int h[N], e[N], ne[N], idx;
int f[N][N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void dfs(int u){
    for(int i = h[u]; ~i; i = ne[i]){ // 循环物品组
        int son = e[i];
        dfs(son);
        // 走到这里，就表示物品组中的每个物品已经准备好了
        // 留出根节点的位置，因为如果选择子树中的点的话，根节点是必选的
        for(int j = m - v[u]; j >= 0; j--) // 循环体积
            for(int k = 0; k <= j; k++) // 循环决策(选中的子树体积数)
                f[u][j] = max(f[u][j], f[u][j-k] + f[son][k]);
    }
    // 将物品u加进去
    // 如果max中加了子树的节点，那么根节点必加
    // 如果没加任何子树的节点，那么max必然是根节点自身
    // 总之，能装根节点，则max必然装下根节点
    for(int i = m; i >= v[u]; i--)
        f[u][i] = f[u][i-v[u]] + w[u];
    // 如果连根节点都放不下，那么子节点就更没可能放下了
    for(int i = 0; i < v[u]; i++)
        f[u][i] = 0;
}

int main(){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    int root;
    for(int i = 1; i <= n; i++){
        int p;
        cin >> v[i] >> w[i] >> p;
        if(p == -1) root = i;
        else add(p, i);
    }
    
    dfs(root);
    
    cout << f[root][m] << endl;
    return 0;
}
```

